struct Stack_f64 { u64 count; u64 cap; f64 *dat; }; void stack_init(Stack_f64 *stack, u64 cap) { stack->count = 0; stack->cap = cap; stack->dat = (f64 *)calloc(stack->cap, sizeof(f64)); } void stack_push(Stack_f64 *stack, f64 v) { if (stack->cap == 0) stack_init(stack, 1 << 14); assert(stack->count < stack->cap); stack->dat[stack->count++] = v; } f64 stack_pop(Stack_f64 *stack) { assert(stack->count > 0); return stack->dat[--stack->count]; } struct Stack_Nodep { u64 count; u64 cap; Node * *dat; }; void stack_init(Stack_Nodep *stack, u64 cap) { stack->count = 0; stack->cap = cap; stack->dat = (Node * *)calloc(stack->cap, sizeof(Node *)); } void stack_push(Stack_Nodep *stack, Node * v) { if (stack->cap == 0) stack_init(stack, 1 << 14); assert(stack->count < stack->cap); stack->dat[stack->count++] = v; } Node * stack_pop(Stack_Nodep *stack) { assert(stack->count > 0); return stack->dat[--stack->count]; } struct Stack_Error { u64 count; u64 cap; Error *dat; }; void stack_init(Stack_Error *stack, u64 cap) { stack->count = 0; stack->cap = cap; stack->dat = (Error *)calloc(stack->cap, sizeof(Error)); } void stack_push(Stack_Error *stack, Error v) { if (stack->cap == 0) stack_init(stack, 1 << 14); assert(stack->count < stack->cap); stack->dat[stack->count++] = v; } Error stack_pop(Stack_Error *stack) { assert(stack->count > 0); return stack->dat[--stack->count]; } struct Stack_Item { u64 count; u64 cap; Item *dat; }; void stack_init(Stack_Item *stack, u64 cap) { stack->count = 0; stack->cap = cap; stack->dat = (Item *)calloc(stack->cap, sizeof(Item)); } void stack_push(Stack_Item *stack, Item v) { if (stack->cap == 0) stack_init(stack, 1 << 14); assert(stack->count < stack->cap); stack->dat[stack->count++] = v; } Item stack_pop(Stack_Item *stack) { assert(stack->count > 0); return stack->dat[--stack->count]; }
