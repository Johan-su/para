
/* automatically generated by rust-bindgen 0.64.0 */

#![allow(dead_code)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
use core::{ffi::c_void, mem::transmute};



#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const PRINT_EVERY_PARSE_STEP: u32 = 1;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value:
    __vcrt_va_list_is_reference__bindgen_ty_1 = false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type U8 = u8;
pub type U16 = u16;
pub type U32 = u32;
pub type U64 = u64;
pub type Usize = usize;
pub type I8 = i8;
pub type I16 = i16;
pub type I32 = i32;
pub type I64 = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseTable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseToken {
    pub token_type: I64,
    pub data: *const ::std::os::raw::c_char,
    pub length: U32,
}
#[test]
fn bindgen_test_layout_ParseToken() {
    const UNINIT: ::std::mem::MaybeUninit<ParseToken> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ParseToken>(),
        24usize,
        concat!("Size of: ", stringify!(ParseToken))
    );
    assert_eq!(
        ::std::mem::align_of::<ParseToken>(),
        8usize,
        concat!("Alignment of ", stringify!(ParseToken))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).token_type) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseToken),
            "::",
            stringify!(token_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseToken),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseToken),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct Expr {
    pub token: ParseToken,
    pub expr_count: U32,
    pub exprs: __IncompleteArrayField<*mut Expr>,
}
#[test]
fn bindgen_test_layout_Expr() {
    const UNINIT: ::std::mem::MaybeUninit<Expr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Expr>(),
        32usize,
        concat!("Size of: ", stringify!(Expr))
    );
    assert_eq!(
        ::std::mem::align_of::<Expr>(),
        8usize,
        concat!("Alignment of ", stringify!(Expr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Expr),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).expr_count) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Expr),
            "::",
            stringify!(expr_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exprs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Expr),
            "::",
            stringify!(exprs)
        )
    );
}
extern "stdcall"
{
    fn LoadLibraryA(lpLibFileName: *const u8) -> *const c_void;
    fn FreeLibrary(hLibModule: *const c_void) -> bool;
    fn GetProcAddress(hModule: *const c_void, lpProcName: *const u8) -> *const c_void;
}

    type write_parse_table_from_bnf_t = fn(
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: U32,
        src: *const ::std::os::raw::c_char,
    ) -> U32;
    type create_parse_table_from_bnf_t = fn(
        src: *const ::std::os::raw::c_char,
    ) -> *mut ParseTable;
    type graphviz_from_syntax_tree_t = fn(
        file_path: *const ::std::os::raw::c_char,
        tree_list: *mut Expr,
    );
    type parse_t = fn(
        token_list: *mut ParseToken,
        token_count: U32,
        table: *mut ParseTable,
        flags: U32,
        opt_tree_out: *mut *mut Expr,
        opt_error_msg_out: *mut ::std::os::raw::c_char,
        msg_buf_size: Usize,
    ) -> bool;
    type parse_bin_t = fn(
        token_list: *mut ParseToken,
        token_count: U32,
        table: *mut U8,
        flags: U32,
        opt_tree_out: *mut *mut Expr,
        opt_error_msg_out: *mut ::std::os::raw::c_char,
        msg_buf_size: Usize,
    ) -> bool;
    type get_table_size_t = fn(table: *mut ParseTable) -> U32;
    type print_table_t = fn(table: *mut ParseTable);


pub static mut write_parse_table_from_bnf: write_parse_table_from_bnf_t = |_, _, _,| 0;
pub static mut create_parse_table_from_bnf: create_parse_table_from_bnf_t = |_| 0 as *mut ParseTable;
pub static mut graphviz_from_syntax_tree: graphviz_from_syntax_tree_t = |_, _| ();
pub static mut parse: parse_t = |_, _, _, _, _, _, _| false;
pub static mut parse_bin: parse_bin_t = |_, _, _, _, _, _, _| false;
pub static mut get_table_size: get_table_size_t = |_| 0;
pub static mut print_table: print_table_t = |_| ();
pub static mut ptg_dll: *const c_void = 0 as *const c_void;

pub fn load_ptg() -> bool
{
    unsafe
    {
        ptg_dll = LoadLibraryA(b"./lib/ptg.dll\0".as_ptr());
        
        if ptg_dll == 0 as *const c_void
        {
            println!("Failed to load ptg_dll");
            return false;  
        }

        {
            let addr = GetProcAddress(ptg_dll, b"write_parse_table_from_bnf\0".as_ptr());
            if addr == 0 as *const c_void
            {
                println!("Failed to load write_parse_table_from_bnf");
            }
            write_parse_table_from_bnf = transmute::<*const c_void, write_parse_table_from_bnf_t>(addr);
        }
        {
            let addr = GetProcAddress(ptg_dll, b"create_parse_table_from_bnf\0".as_ptr());
            if addr == 0 as *const c_void
            {
                println!("Failed to load create_parse_table_from_bnf");
            }
            create_parse_table_from_bnf = transmute::<*const c_void, create_parse_table_from_bnf_t>(addr);
        }
            {
            let addr = GetProcAddress(ptg_dll, b"graphviz_from_syntax_tree\0".as_ptr());
            if addr == 0 as *const c_void
            {
                println!("Failed to load graphviz_from_syntax_tree");
            }
            graphviz_from_syntax_tree = transmute::<*const c_void, graphviz_from_syntax_tree_t>(addr);
        }
        {
            let addr = GetProcAddress(ptg_dll, b"parse\0".as_ptr());
            if addr == 0 as *const c_void
            {
                println!("Failed to load parse");
            }
            parse = transmute::<*const c_void, parse_t>(addr);
        }
        {
            let addr = GetProcAddress(ptg_dll, b"parse_bin\0".as_ptr());
            if addr == 0 as *const c_void
            {
                println!("Failed to load parse_bin");
            }
            parse_bin = transmute::<*const c_void, parse_bin_t>(addr);
        }
        {
            let addr = GetProcAddress(ptg_dll, b"get_table_size\0".as_ptr());
            if addr == 0 as *const c_void
            {
                println!("Failed to load get_table_size");
            }
            get_table_size = transmute::<*const c_void, get_table_size_t>(addr);
        }
        {
            let addr = GetProcAddress(ptg_dll, b"print_table\0".as_ptr());
            if addr == 0 as *const c_void
            {
                println!("Failed to load print_table");
            }
            print_table = transmute::<*const c_void, print_table_t>(addr);
        }
    }
    return true;
}

pub fn unload_ptg() -> bool
{
    unsafe
    {
        write_parse_table_from_bnf = |_, _, _,| 0;
        create_parse_table_from_bnf = |_| 0 as *mut ParseTable;
        graphviz_from_syntax_tree = |_, _| ();
        parse = |_, _, _, _, _, _, _| false;
        parse_bin = |_, _, _, _, _, _, _| false;
        get_table_size = |_| 0;
        print_table = |_| ();
        ptg_dll = 0 as *const c_void;
        if ptg_dll != 0 as *const c_void
        {
            return FreeLibrary(ptg_dll);
        }

    }
    return false;
}